======================
Promises and Callbacks
======================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecols

Overview
--------

The NodeJS driver uses the asynchronous Javascript API to communicate with
your MongoDB cluster.

Asynchronous Javascript allows you to execute operations without waiting for
the processing thread to become free. This helps prevent your application
from becoming unresponsive to web UI rendering or network requests when
executing long-running operations. For more information about asynchronous
Javascript, see the MDN web documentation on
`Asynchronous Javascript <https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous>`_.

This section describes two features of asynchronous Javascript --
`Promises`_ and `Callbacks`_ -- that you can use with the NodeJS driver to
access the results of your method calls to your MongoDB cluster.

Promises
--------

A Promise is an object returned by the asynchronous method call that allows
you to access information on the eventual success or failure of the operation.
They are often used to execute operations that take some time and have
when you want to notify once it's completed. For more information on Promises
and related terminology, see the MDN documentation on
:mdn:`Promises <Web/JavaScript/Reference/Global_Objects/Promise>`.

If you call a driver method such as ``findOneAndModify()``,
``countDocuments()``, or ``update()``, the NodeJS driver returns a Promise.

You can use the ``await`` operator inside of an ``async`` method on the
Promise to cause the enclosing method to pause until the Promise reaches
either the **Fulfilled** or **Rejected** state. If it reaches the **Fulfilled**
state, the reference contains the operation result as an object or value.

.. code-block:: js

   async function run() {
     ...
     const result = await collection.insertOne({ name: "Mount Everest", meters: 8848 });

     // print the result of the insertOne() call
     console.log(result);
   }

If you want to execute logic once the Promise reaches the **Fulfilled**
or **Rejected** state, you can append the ``then()`` method to the Promise.
The first parameter is the method that gets called when the Promise reaches
the **Fulfilled** state and the optional second parameter is the method that
gets called when it reaches the **Rejected** state. These methods are called
**callbacks** because they execute only after the Promise completes.

.. code-block:: js

   ...
   collection.updateOne({ name: "Mount McKinley" }, { meters: 6190 })
     .then(
       res => console.log(`Updated ${res.result.n} documents`),
       err => console.error(`Something went wrong: ${err}`)
     );

If you only need to handle transitions to the **Rejected** state, use the
``catch()`` method which accepts a single callback, executed when the Promise
transitions to the **Rejected** state.

.. code-block:: js

     const deleteResult = await collection.deleteOne({ name: "Mount Doom" })
       .catch(err => console.error(`Fatal error occurred: ${err}`));

.. note::

   Certain methods in the driver such as ``find()`` return a ``Cursor``
   instead of a Promise. To determine what type each method returns, refer to
   the :node-api:`NodeJS API documentation <>`.

Callbacks
---------

A callback is a method that gets called after another method has
finished executing. This allows the enclosing method to continue to execute
other commands until the original operation completes. Callbacks are often
used to enforce the order of processing commands.

In the MongoDB NodeJS driver, you can optionally declare a callback method to
async operations that normally return Promises such as ``findOneAndUpdate()``,
``countDocuments()``, or ``update()``. Once the operation completes execution,
the callback method executes as shown in the following code snippet:

.. code-block:: js

   collection.findOneAndUpdate({ name: "Barronette Peak" }, { name: "Baronette Peak" },
     function(error, result) {
       if (!error) {
         console.log(`Operation completed successfully: ${result.ok}`);
       } else {
         console.log(`An error occurred: ${error}`);
       }
    });

For more information on the callback method signature for the specific
driver method, see the :node-api:`API documentation <>`.

 .. note::

    If you specify a callback, the method *does not* return a Promise.

Operational Considerations
--------------------------

When using ``async`` methods, use ``await`` when you call methods
that return Promises to ensure they complete before executing any other
logic that depends on the result. Consider the following example in which
we iterate over a cursor using ``hasNext()``, which returns a Promise that
resolves to a boolean that indicates whether additional results exist, and
``next()`` which returns a Promise that resolves to the next entry the
cursor is pointing to.

One common mistake is to forget to use ``await`` to get the value of the
result rather than the Promise object. Consider the following code:

.. code-block:: js

   // WARNING: this snippet may cause an infinite loop
   const cursor = collection.find();

   while (cursor.hasNext()) {
      console.log(cursor.next());
   }

Since the call to ``hasNext()`` returns a ``Promise``, the conditional
statement returns ``true`` regardless of the value that it resolves to.

If we alter the code to ``await`` the call to ``next()`` only, as demonstrated
in the following code snippet, it throws the following error:
``MongoError: Cursor is closed``.

.. code-block:: js

   // WARNING: this snippet throws a MongoError
   const cursor = collection.find();

   while (cursor.hasNext()) {
      console.log(await cursor.next());
   }

While ``hasNext()`` is not called until after the result of ``next()`` returns,
the call to ``hasNext()`` returns a Promise which evaluates to ``true`` rather
than the value it resolves to, similar to the prior example. The code
attempts to call ``next()`` on a Cursor that has already returned its results
and closed as a result.

If we alter the code to only ``await`` the call to ``hasNext()`` as shown in
the following example, the console prints Promise objects rather than the
document objects.

.. code-block:: js

   // WARNING: this snippet prints Promises instead of the objects they resolve to
   const cursor = collection.find();

   while (await cursor.hasNext()) {
      console.log(cursor.next());
   }

Use ``await`` before both the ``hasNext()`` and ``next()`` method calls to
ensure that you are operating on the correct return values as demonstrated
in the following code:

.. code-block:: js

   const cursor = collection.find();

   while (await cursor.hasNext()) {
      console.log(await cursor.next());
   }

.. note::

   For additional information on using Promises and Callbacks with the MongoDB
   NodeJS driver, see this MongoDB University course video on `asynchronous
   Javascript programming <https://youtu.be/R4AEyKehpss>`_.
